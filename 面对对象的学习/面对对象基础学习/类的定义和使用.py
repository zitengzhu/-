'''
在python中，类表示具有相同属性和方法的对象的集合。在使用类时，需要先定义类，然后创建类的实例
通过类的实例就可以访问类中的属性和方法。
'''
# 在python中，类的定义使用 class 关键字来实现
# class Geese:
    # '''大雁类'''
    # pass
'''
Geese 是指定的类名  意为创建了一个Geese类
大雁类 用于指定类的文本字符串，定义该字符串后，在创建类的对象时，输入类名和左侧的括号"("
将显示该信息
'''


'--------------------创建类的实例------------------------'
# class 本身并不能创建该类的任何实例。因此在类的定义完成以后，可以创建类的实例
# 即实例化类的对象。
# geese = Geese()
# print(geese)  <__main__.Geese object at 0x000001D983562C90> 由此可以看出geese是Geese的实例


'-------------------创建_init_()方法-----------------------------'
'''
每当创建类后，通常会创建一个_init_()方法，该方法是一个特殊方法。每当创建一个类的新实例时，python都会自动执行一边它
_init_()方法中必须包括一个self参数，并且必须时第一个参数。self参数时一个指向实例本身的引用，用于访问类中的属性和方法
在方法被调用时会自动传递实际参数self。因此，在_init_()方法中只有一个参数的情况下，在创建类的实例时就无需指定实际参数。
注：在_init_()方法的名称中，开头和结尾处均为双下划线，这是一种约定，旨在区分python中默认方法和普通方法
'''
# class Geese:
    # def __init__(self):
        # print('我是大雁类')

# geese = Geese()   # 创建名为geese的实例

# 在 __init__()方法中，除self参数外，还可以自定义一些参数，参数间使用逗号进行分隔。
# 例如，下面的代码将在创建__init__()方法时再指定三个参数，分别为 beak，wing和claw。

'''
class Geese:
    #"""大雁类"""
    def __init__(self,beak,wing,claw):   # 创建方法
        print('我是大雁类,我有以下特征')
        print(beak)
        print(wing)
        print(claw)
        
beak = '鸟喙大'    # beak的数据
wing = '翅膀长'    # wing的数据
claw = '爪子是蹼状' # claw的数据
wildGeese = Geese(beak,wing,claw)  # 将定义好的数据导入类中并进行 实例的创建
 
我是大雁类,我有以下特征
鸟喙大
翅膀长
爪子是蹼状
'''


'------------------创建类的成员并访问------------------------------'
# 类的成员主要由实例方法和数据成员组成。在类中创建了类的成员后，可以通过类的实例进行访问

# 1.创建实例方法并访问
# 所谓实例方法(行为)，是指在类的定义中的函数。该函数是一种在实例上操作的函数。
# 注:实例方法和python中的函数的主要区就是，函数实现某个独立的功能，而实例方法则实现类中的某个行为，属于类的一部分
# 在成功创建实例方法后，可以通过类的实例名称和点(.)操作符进行访问’

'''
class Geese:
    # """大雁类"""
    def __init__(self, beak, wing, claw):  # 创建方法
        print('我是大雁类,我有以下特征')
        print(beak)
        print(wing)
        print(claw)
    def fly(self,state):
        print(state)

beak = '鸟喙大'  # beak的数据
wing = '翅膀长'  # wing的数据
claw = '爪子是蹼状'  # claw的数据
wildGeese = Geese(beak, wing, claw)  # 将定义好的数据导入类中并进行 实例的创建
wildGeese.fly('我飞的贼拉高')  # .fly()中的  我飞的贼拉高 是将自定义的数据 我飞的贼拉高 导入变量state 在实例方法中进行使用  简而言之括号内的数据就是变量的参数

我是大雁类,我有以下特征
鸟喙大
翅膀长
爪子是蹼状
我飞的贼拉高
'''

'---------------------------创建数据成员并访问它们------------------------------------'
# 数据成员是指类中定义的变量，即属性。根据定义位置，又可以分为类属性和实例属性
# -------------------------------------1.类属性
#   类属性是指定义在类中，并且是在函数体外的属性。类属性可以在类的所有实例之间共享值，也就是说，类属性在实例化的对象中都可以使用 是公用的。 类属性可以通过类名称或者实例名访问
'''
class Geese:
    """雁类"""
    neck = '脖子较长'  # 脖子属性  所有雁的实例都共有的特点
    wing = '振翅频率高'  # 翅膀属性  所有雁的实例都共有的特点
    leg = '推位于身子两侧'  # 腿属性  所有雁的实例都共有的特点
    def __init__(self):
        print('我属于雁类，我有一下特征:')
        print(Geese.neck)  # 访问Geese中的脖子属性
        print(Geese.leg)  # 访问Geese中的腿属性
        print(Geese.wing)  # 访问Geese中的翅膀属性

geese = Geese() # 创建实例

我属于雁类，我有一下特征:
脖子较长
推位于身子两侧
振翅频率高
'''
'''
# 实例
class Geese:
    """雁类"""
    neck = '脖子较长'  # 脖子属性  所有雁的实例都共有的特点
    wing = '振翅频率高'  # 翅膀属性  所有雁的实例都共有的特点
    leg = '推位于身子两侧'  # 腿属性  所有雁的实例都共有的特点
    number = 0
    def __init__(self):
        Geese.number+=1  # 每运行一次都加1
        print('\n'+'我是第',Geese.number,'只大雁')  # 输出编号
        print('我属于雁类，我有一下特征:')
        print(Geese.neck)  # 访问Geese中的脖子属性
        print(Geese.leg)  # 访问Geese中的腿属性
        print(Geese.wing)  # 访问Geese中的翅膀属性

# 创建四个实例
list1=[]
for i in range(4):
    list1.append(Geese())

我是第 1 只大雁
我属于雁类，我有一下特征:
脖子较长
推位于身子两侧
振翅频率高

我是第 2 只大雁
我属于雁类，我有一下特征:
脖子较长
推位于身子两侧
振翅频率高

我是第 3 只大雁
我属于雁类，我有一下特征:
脖子较长
推位于身子两侧
振翅频率高

我是第 4 只大雁
我属于雁类，我有一下特征:
脖子较长
推位于身子两侧
振翅频率高


# 在python中除了可以通过类名称访问类属性，还可以动态的为类属性添加对象
Geese.beak = '我是小燕子'  # 在雁类的属性中动态添加属性
print('\n'+list1[0].beak)  我是小燕子

注:除了动态地为类和对象添加属性，也可以修改类属性。修改结果将作用于该类的所有实例
'''


# -------------------------------------1.实例属性
# 实例属性是指定义在类的方法中的属性，只能用于当前实例
# class Geese:
    # """雁类"""
    # def __init__(self):
        # self.neck = '脖子较长'  # 脖子属性     属于init方法中的实例属性只能作用于由他产生的实例  不能通过类名访问
        # self.wing = '振翅频率高'  # 翅膀属性   属于init方法中的实例属性只能作用于由他产生的实例   不能通过类名访问
        # self.leg = '推位于身子两侧'  # 腿属性   属于init方法中的实例属性只能作用于由他产生的实例  不能通过类名访问
        # print('我属于雁类，我有一下特征:')
        # print(self.neck)  # 访问脖子属性
        # print(self.leg)  # 访问腿属性
        # print(self.wing)  # 访问翅膀属性

# a = Geese() # 创建实例
# 我属于雁类，我有一下特征:
# 脖子较长
# 推位于身子两侧
# 振翅频率高
'''
实例属性只能通过实例名来访问。不能通过类名访问实例属性
实例属性也可以通过实例名称进行修改，与类属性不同，通过实例名称修改实例属性后，并不影响该类的其他实例中对应的实例属性
'''
'''
class Geese:  # 创建类
    """雁类"""
    def __init__(self):   # 进行初始化
        self.neck = '脖子较长'  # 创建实例属性

geese1 = Geese()     # 创建实例
geese2 = Geese()     # 创建实例
geese1.neck='我是特殊的我脖子短'  # 修改geese1的实例属性   geese2的实例属性不变   类中的实例属性也不变
# print('geese1的neck属性为：',geese1.neck)  geese1的neck属性为： 我是特殊的我脖子短
# print('geese2的neck属性为：',geese2.neck)  geese2的neck属性为： 脖子较长
'''


'------------------------限制访问--------------------------------'
'''
在类的内部可以定义属性和方法，而在类的外部则可以直接调用属性或方法来进行数据操作，从而隐藏了类内部的复杂逻辑。但是，在python中并没有对属性和方法
的访问权限进行限制。为了保证类内部的某些属性或方法不被外部访问，可以在属性或方法前面加上双下划线或者首部都加双下划线，从而限制访问权限
1.前后都加双下划线表示定义特殊方法，一般是系统定义的名字 
2.双下划线表示私有类型的成员，只允许定义该方法的类本身对进行访问，而不允许通过类的实例对其进行访问，但可以通过类的实例名._类命_xxx方法访问他们
'''
class Swan:
    '''天鹅类'''
    __neck_swan = '我的脖子很长'  #设置私有属性  属性neck_swan是天鹅脖子的类属性
    def __init__(self):
        print(Swan.__neck_swan)
swan = Swan()  # 创建实例
# swan是实例名  Swan是类名  __neck_swan 是私有属性
print('加入类名：',swan._Swan__neck_swan)  # 加入类名： 我的脖子很长
print('直接访问：',Swan.__neck_swan)  # 会报错
# AttributeError: type object 'Swan' has no attribute '__neck_swan'. Did you mean: '_Swan__neck_swan'?




















