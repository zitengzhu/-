'''
概述：
    内部函数，使用了外部函数的变量，这种写法称之为闭包
格式：
    def 外部函数(形式参数):
        外部函数的变量
        def 内部函数(形式参数):
            使用外部函数的变量
        return 内部函数
    前提条件：
        1.有嵌套         外部函数嵌套内部函数
        2.有引用         内部函数使用外部函数的变量
        3.有返回         外部函数中，返回 内部函数名(对象)
细节：
    1.函数和函数()是两个概念，函数表示函数对象，函数()表示调用函数，获取返回值

闭包的特点：
记忆功能：内部函数能记住创建时的环境
数据封装：外部变量被"封装"在闭包内部
状态保持：即使外部函数执行完毕，变量值仍然保留
'''


def get_sum(a,b):
    return a+b
print(get_sum)  # <function get_sum at 0x00000238BCBF04A0> 对象
print(get_sum(10,20))  # 30 调用函数获取返回值

# 函数名赋值给变量
my_sum = get_sum  # 将函数get_sum赋值给my_sum这个变量   变量my_sum就拥有了和函数get_sum一样的函数体
print(my_sum)  # <function get_sum at 0x000001B3CC0885E0> 对象
print(my_sum(10,20))  # 30

# 演示闭包写法
# 需求：定义求和闭包，外部函数有参数num1，内部函数有参数num2，调用，求和

# 定义外部函数
def fun_outer(num1):
    # 定义内部函数
    def fun_inner(num2):   # 嵌套
        sum = num2+num1    # 引用
        print(f'求和结果为{sum}')
    return fun_inner  # 返回函数本身的引用

# # 调用上述函数
fun_inner = fun_outer(10)
# 利用变量 fun_inner 接收 fun_outer(num1) 这个函数  因为 闭包具有记忆性可以记住创建他的环境 fun_outer传如参数10 那么闭包就会记住这个10 并调用内部函数
'''
这时 调用外部函数时运行的逻辑
fun_outer(10) 执行，num1 被赋值为 10
在 fun_outer 内部定义了 fun_inner 函数
关键点：fun_inner 记住了 num1 = 10 这个值
return fun_inner 返回了内部函数的引用（不是调用）
'''
# fun_inner(20)
# 调用外部函数时变量 fun_inner接收了外部函数的值 那么相当于  fun_inner这个变量其实就是内部函数 并且这个内部函数记住了外部函数传入的参数10
# fun_inner(20)相当于给内部函数fun_inner传入num2=20这个参数 又欣慰 内部函数记住了num1=10所以会执行 sum来进行求和计算
# 求和结果为30

fun_outer(10)(20)
# 求和结果为30
'''
闭包 = 内部函数 + 外部函数的变量环境
就像是一个"记忆盒子"：
内部函数 fun_inner 是盒子的功能
外部变量 num1=10 是盒子记住的东西
'''

# 注： return 返回的值一定是一个函数引用而不能是函数调用 如果返回的是函数调用那么在外部函数进行传参是输入了num1=10后会直接执行内部函数这回导致报错
# 因为如果返回的是函数的调用那么在传入num=10时会直接调用内部函数执行sum的求和这回导致缺少num2这个变量的数据导致报错
# 通俗来说就是
# 返回函数引用执行上述代码相当于给了你一个记住num1=10的计算机你可以在这个基础上进行求和运算，你想什么时候计算都可以只要你传入了参数num2
# 返回番薯调用执行上述代码相当于给了你一个记住num1=10的计算机但它会在你没有传入num2参数时直接运行求和计算这回导致求和缺少参数进而产生错误
# 因此返回值一定要是函数的应用 而不是函数的调用

'''
关于内部函数和外部函数运行逻辑的详细解释：  （假设:外部函数的地址值为0x01，内部函数的地址值为:0x02）
在上述代码中外部函数的函数体内存在两行代码 def fun_inner(num2) 和  return fun_inner
在用变量 fun_inner接收外部函数后，外部函数开始运行。此时变量fun_inner接收到的地址值是0x01，变量开始调用外部函数，第一行代码为内部函数，没有进行调用，这行代码没有效果
在外部函数的最后一行return返回内部函数的引用，内部函数的地址值为0x02，return返回了0x02这个地址值，此时变量fun_inner的地址值就从0x01变为0x02
它从指向外部函数的引用变为了指向内部函数的引用，变量fun_inner此时就和内部函数具有了一样的函数体
即变量fun_inner就是内部函数fun_inner(num2)
'''

'''
案例：闭包关键字 nonlocal的学习

nonlocal：
    它是python的关键字，可以实现在函数内部调用函数外部的变量值
'''

# 定义外部函数
def fun_outer():
    a=100
    def fun_inner():
        nonlocal a
        a=a+1
        print(f'a的值为:{a}')
    return fun_inner

if __name__ == '__main__':
    fun_inner = fun_outer()
    fun_inner()  # a的值为:101
    fun_inner()  # a的值为:102
# 注：在运行上述函数时在内部函数使用了nonlocal关键字 通过它可以实现内部函数修改外部函数的值
# 在第一此调用内部函数时 a = 100+1 a的数据就被修改为了101
# 在第二此调用内部函数时 a = 101+1 a的数据就被修改为了102
# 如果不加关键字nonlocal 那么在 定义变量fun_inner接收外部函数时  外部函数的程序跑完后系统会进行弹栈让a=100这个内部函数的数据被消除
# 这回导致后续的内部函数计算报错







